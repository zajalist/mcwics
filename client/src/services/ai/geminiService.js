/**
 * Gemini AI Service for LockStep
 * Handles AI-generated content for puzzles, stories, and clues
 */

const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY;
const GEMINI_API_ROOT = 'https://generativelanguage.googleapis.com/v1beta';
const DEFAULT_MODELS = [];

function normalizeModelName(name) {
  if (!name) return '';
  return name.startsWith('models/') ? name.slice('models/'.length) : name;
}

function buildModelList(model, modelFallbacks) {
  const base = [];
  if (model) base.push(model);
  if (Array.isArray(modelFallbacks)) base.push(...modelFallbacks);
  if (base.length === 0) base.push(...DEFAULT_MODELS);
  return [...new Set(base.map(normalizeModelName))].filter(Boolean);
}

export async function listGeminiModels(options = {}) {
  const apiKey = options.apiKey || GEMINI_API_KEY;
  if (!apiKey) {
    throw new Error('GEMINI_API_KEY not configured. Add VITE_GEMINI_API_KEY to your .env file.');
  }

  const response = await fetch(`${GEMINI_API_ROOT}/models?key=${apiKey}`);
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(`Gemini API error: ${errorData.error?.message || response.statusText}`);
  }

  const data = await response.json();
  const models = Array.isArray(data.models) ? data.models : [];
  return models
    .filter(model => (model.supportedGenerationMethods || []).includes('generateContent'))
    .map(model => ({
      name: model.name,
      normalizedName: normalizeModelName(model.name),
      displayName: model.displayName,
      description: model.description,
      supportedGenerationMethods: model.supportedGenerationMethods
    }));
}

/**
 * Generate content using Gemini AI
 * @param {string} prompt - The prompt to send to Gemini
 * @param {Object} options - Additional options
 * @returns {Promise<Object>} - Generated content
 */
export async function generateWithGemini(prompt, options = {}) {
  const apiKey = options.apiKey || GEMINI_API_KEY;
  if (!apiKey) {
    throw new Error('GEMINI_API_KEY not configured. Add VITE_GEMINI_API_KEY to your .env file.');
  }

  const {
    temperature = 0.7,
    maxOutputTokens = 2048,
    topK = 40,
    topP = 0.95,
    model,
    modelFallbacks
  } = options;

  const modelList = buildModelList(model, modelFallbacks);
  if (modelList.length === 0) {
    throw new Error('No available Gemini models. Use list models to select a valid model.');
  }
  let lastError = null;

  try {
    for (const modelName of modelList) {
      const response = await fetch(`${GEMINI_API_ROOT}/models/${modelName}:generateContent?key=${apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: prompt }]
          }],
          generationConfig: {
            temperature,
            maxOutputTokens,
            topK,
            topP,
          },
          safetySettings: [
            {
              category: 'HARM_CATEGORY_HARASSMENT',
              threshold: 'BLOCK_MEDIUM_AND_ABOVE'
            },
            {
              category: 'HARM_CATEGORY_HATE_SPEECH',
              threshold: 'BLOCK_MEDIUM_AND_ABOVE'
            },
            {
              category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
              threshold: 'BLOCK_MEDIUM_AND_ABOVE'
            },
            {
              category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
              threshold: 'BLOCK_MEDIUM_AND_ABOVE'
            }
          ]
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        lastError = {
          status: response.status,
          message: errorData.error?.message || response.statusText,
          model: modelName
        };
        if ([400, 403, 404, 429].includes(response.status)) {
          continue;
        }
        break;
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;

      if (!generatedText) {
        lastError = { status: 500, message: 'No content generated by Gemini', model: modelName };
        continue;
      }

      return {
        success: true,
        text: generatedText,
        raw: data,
        model: modelName
      };
    }

    const errorMessage = lastError
      ? `Gemini API error: ${lastError.message} (model: ${lastError.model})`
      : 'Gemini API error: Unknown error';
    const err = new Error(errorMessage);
    err.status = lastError?.status;
    err.model = lastError?.model;
    throw err;
  } catch (error) {
    console.error('Gemini API error:', error);
    return {
      success: false,
      error: error.message,
      status: error.status,
      model: error.model,
      text: null
    };
  }
}

/**
 * Enhance existing puzzle content with AI improvements
 * @param {Object} aiConfig - AI configuration from AINode
 * @param {Object} existingContent - Current puzzle node content to enhance
 * @returns {Promise<Object>} - Enhanced content with improvements
 */
export async function enhancePuzzleContent(aiConfig, existingContent = {}, options = {}) {
  const { prompt, enhances = [] } = aiConfig;

  if (!prompt) {
    throw new Error('No prompt provided for AI enhancement');
  }

  // Build context-aware prompt for enhancement
  let fullPrompt = `You are enhancing an existing puzzle node. Here's what currently exists:\n\n`;
  
  if (existingContent.story) {
    fullPrompt += `Current Story:\nTitle: ${existingContent.story.title || 'Untitled'}\nText: ${existingContent.story.text || 'No text'}\n\n`;
  }
  if (existingContent.puzzles && existingContent.puzzles.length > 0) {
    fullPrompt += `Current Puzzles (${existingContent.puzzles.length}):\n`;
    existingContent.puzzles.forEach((p, i) => {
      fullPrompt += `${i + 1}. Type: ${p.type}, Prompt: ${p.prompt || 'No prompt'}\n`;
    });
    fullPrompt += '\n';
  }
  if (existingContent.roleClues && existingContent.roleClues.length > 0) {
    fullPrompt += `Current Role Clues (${existingContent.roleClues.length}):\n`;
    existingContent.roleClues.forEach(rc => {
      fullPrompt += `- ${rc.roleId}: ${rc.text}\n`;
    });
    fullPrompt += '\n';
  }

  fullPrompt += `Enhancement Instructions: ${prompt}\n\n`;
  fullPrompt += 'Please provide:\n';
  
  if (enhances.includes('improveText')) {
    fullPrompt += '- Improved, more engaging text for story and puzzles\n';
  }
  if (enhances.includes('addImages')) {
    fullPrompt += '- Detailed descriptions for images that should be generated (we will generate actual images separately)\n';
  }
  if (enhances.includes('addVideos')) {
    fullPrompt += '- Concepts for videos or animations that would enhance understanding\n';
  }

  fullPrompt += '\nReturn the enhanced content in JSON format, preserving the structure but with improvements.';

  const result = await generateWithGemini(fullPrompt, {
    temperature: 0.7,
    maxOutputTokens: 2048,
    ...options
  });

  if (!result.success) {
    throw new Error(result.error);
  }

  // Try to parse as JSON, fallback to text
  try {
    const jsonMatch = result.text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
  } catch (e) {
    console.warn('Could not parse AI response as JSON, returning raw enhancements');
  }

  return {
    improvedText: result.text,
    imageDescriptions: [],
    videoDescriptions: []
  };
}

/**
 * Generate story narrative
 * @param {string} prompt - Story prompt
 * @param {Object} context - Story context
 * @returns {Promise<Object>} - Generated story with title and text
 */
export async function generateStory(prompt, context = {}) {
  const fullPrompt = `
${prompt}

${context.scenarioTitle ? `Scenario: ${context.scenarioTitle}` : ''}
${context.location ? `Location: ${context.location}` : ''}

Generate a compelling story with:
1. A short, punchy title (5-8 words max)
2. Narrative text (2-3 paragraphs)
3. Optional narration text (what a narrator would say)

Return as JSON:
{
  "title": "...",
  "text": "...",
  "narrationText": "..."
}
`;

  const result = await generateWithGemini(fullPrompt, { temperature: 0.9 });
  
  if (!result.success) {
    throw new Error(result.error);
  }

  try {
    const jsonMatch = result.text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
  } catch (e) {
    // Fallback: return raw text as story text
    return {
      title: 'AI Generated Story',
      text: result.text,
      narrationText: ''
    };
  }
}

/**
 * Generate role-specific clues
 * @param {string} prompt - Clue generation prompt
 * @param {Array} roles - Available roles
 * @returns {Promise<Array>} - Generated role clues
 */
export async function generateRoleClues(prompt, roles = ['builder', 'pathfinder', 'decoder', 'coordinator']) {
  const fullPrompt = `
${prompt}

Generate role-specific clues for these roles:
${roles.map(r => `- ${r}`).join('\n')}

Each clue should be 1-2 sentences and provide unique information relevant to that role's responsibilities.

Return as JSON array:
[
  { "role": "builder", "clue": "..." },
  { "role": "pathfinder", "clue": "..." },
  ...
]
`;

  const result = await generateWithGemini(fullPrompt);
  
  if (!result.success) {
    throw new Error(result.error);
  }

  try {
    const jsonMatch = result.text.match(/\[[\s\S]*\]/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
  } catch (e) {
    console.warn('Could not parse role clues as JSON');
    return [];
  }
}

/**
 * Generate puzzle questions/prompts
 * @param {string} basePrompt - Base puzzle context
 * @param {string} puzzleType - Type of puzzle
 * @returns {Promise<Object>} - Generated puzzle content
 */
export async function generatePuzzle(basePrompt, puzzleType) {
  const puzzleInstructions = {
    'choice': 'Generate a multiple choice question with 4 options (1 correct).',
    'input_code': 'Generate a code/text input puzzle with a specific answer.',
    'input_numeric': 'Generate a numeric puzzle with a specific number answer.',
    'cipher': 'Generate a cipher puzzle with encrypted text and a key.',
    'word_puzzle': 'Generate a word puzzle (anagram, crossword clue, etc.).',
    'latex_math': 'Generate a math problem that can be expressed in LaTeX.',
  };

  const instruction = puzzleInstructions[puzzleType] || 'Generate an engaging puzzle.';

  const fullPrompt = `
${basePrompt}

${instruction}

Return as JSON with appropriate fields for the puzzle type.
`;

  const result = await generateWithGemini(fullPrompt, { temperature: 0.8 });
  
  if (!result.success) {
    throw new Error(result.error);
  }

  try {
    const jsonMatch = result.text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
  } catch (e) {
    return { prompt: result.text };
  }
}
